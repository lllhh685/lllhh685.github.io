<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lllhh685.github.io</id>
    <title>lnuBlog</title>
    <updated>2020-10-03T12:25:51.561Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lllhh685.github.io"/>
    <link rel="self" href="https://lllhh685.github.io/atom.xml"/>
    <subtitle>keep trying</subtitle>
    <logo>https://lllhh685.github.io/images/avatar.png</logo>
    <icon>https://lllhh685.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, lnuBlog</rights>
    <entry>
        <title type="html"><![CDATA[MySQL]]></title>
        <id>https://lllhh685.github.io/post/mysql/</id>
        <link href="https://lllhh685.github.io/post/mysql/">
        </link>
        <updated>2020-10-03T12:17:01.000Z</updated>
        <content type="html"><![CDATA[<hr>
<ol>
<li>
<p>删除数据库</p>
<pre><code class="language-mysql">drop database 数据库名;
</code></pre>
</li>
<li>
<p>数据库表</p>
<ul>
<li>
<p>查看表结构</p>
<pre><code class="language-mysql">desc 表名;
show create table 表名;
</code></pre>
</li>
<li>
<p>删除表</p>
<pre><code class="language-mysql">drop table 表名;
</code></pre>
</li>
<li>
<p>数据库表修改名字</p>
<pre><code class="language-mysql">alter table 原表名 rename [to] 新名;
rename table 原表名 to 新名;
</code></pre>
</li>
<li>
<p>增加字段</p>
<pre><code class="language-mysql">alter table 表名 add 列名 数据类型 约束; (最后一列)
alter table 表名 add 列名 数据类型 约束 first; (第一列)
alter table 表名 add 列名 数据类型 约束 after 列名; (在指定字段后增加字段)
</code></pre>
</li>
<li>
<p>删除字段</p>
<pre><code class="language-mysql">alter table 表名 drop 列名;
</code></pre>
</li>
<li>
<p>修改字段</p>
<pre><code class="language-mysql">alter table 表名 modify 列名 新数据类型; (修改表字段类型)
alter table 表名 change 原列名 新列名 原列名类型值; (修改表字段名)
alter table 表名 change 原列名 新列名 新列名类型值; (修改表字段名和类型值)
</code></pre>
</li>
</ul>
</li>
<li>
<p>约束</p>
<ul>
<li>
<p>主键约束</p>
<pre><code class="language-mysql">单一主键
字段名 类型名 primary key,
为主键设置主键名
constraint 主键名 primary key (字段名)
多字段主键
constraint 主键名 primary key (字段1, 字段2)
</code></pre>
</li>
<li>
<p>外键约束</p>
<pre><code class="language-mysql">constraint 外键名 foreign key (外键) references 表名(参考表的参考字段)  
</code></pre>
</li>
</ul>
</li>
<li>
<p>单表查询</p>
<ul>
<li>
<p>去重查询</p>
<pre><code class="language-mysql">select distinct fiele1 ... from 表名
</code></pre>
</li>
<li>
<p>带AND或OR的多条件查询</p>
<pre><code class="language-mysql">select field1 ... from tablename where condition1 and condition2 ...
select field1 ... from tablename where condition1 or condition2 ...
</code></pre>
</li>
<li>
<p>对查询结果进行排序</p>
<pre><code class="language-mysql">select field1 ... from tablename order by fieldm [ASC|DESC]
ASC 升序(默认)
DESC 降序
</code></pre>
</li>
<li>
<p>统计函数</p>
<pre><code class="language-mysql">select function(field) from tablename where condition 
count(*) 不会忽略NULL值
count(field) 会忽略NULL值
avg(field) 会忽略NULL值
</code></pre>
</li>
<li>
<p>LIMIT限制</p>
<pre><code class="language-mysql">select field ... from tablename where condition limit offset_start, row_count;
</code></pre>
</li>
</ul>
</li>
<li>
<p>select子句顺序</p>
<table>
<thead>
<tr>
<th style="text-align:center">子句</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">是否必须使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SELECT</td>
<td style="text-align:center">要返回的列或表达式</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">FROM</td>
<td style="text-align:center">从中检索数据的表</td>
<td style="text-align:center">仅在从表中选择数据时使用</td>
</tr>
<tr>
<td style="text-align:center">WHERE</td>
<td style="text-align:center">行级过滤</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">GROUP BY</td>
<td style="text-align:center">分组说明</td>
<td style="text-align:center">仅在按组计算聚焦时使用</td>
</tr>
<tr>
<td style="text-align:center">HAVING</td>
<td style="text-align:center">组级过滤</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">ORDER BY</td>
<td style="text-align:center">输出排序顺序</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">LIMIT</td>
<td style="text-align:center">要检索的行数</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>多表查询</p>
<ul>
<li>
<p>内连接查询</p>
<pre><code class="language-mysql">select field1, ... from tablename1 inner join tablename2 on condition [inner join tablenamen on condition]
</code></pre>
</li>
<li>
<p>外连接查询</p>
<ul>
<li>
<p>左外连接</p>
<pre><code class="language-mysql">select field1, ... from tablename left join tablename2 on condition
新关系匹配条件时,以关键字 LEFT JOIN 左边的表为参考表,左外连接的结果包括 LEFT OUTER 子句中指定的左表的所有行,如果左表的某行在右表中没有匹配行,在相关联的查询结果中,右表的选择列表均为 NULL
</code></pre>
</li>
<li>
<p>右外连接</p>
<pre><code class="language-mysql">select field1, ... from tablename right join tablename2 on condition
新关系执行匹配条件时,以关键字 RIGHT JOIN 右边的表为参考表
</code></pre>
</li>
<li>
<p>合并查询数据记录</p>
<pre><code class="language-mysql">select field1, ... from tablename1 union | union all select field1, ... from tablename2
关键字 union 会把查询结果集合并在一起,同时去掉重复的数据记录
关键字 union all 会把查询结果直接合并在一起
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子查询</p>
<ul>
<li>
<p>带关键字 EXISTS 的子查询</p>
<pre><code class="language-mysql">关键字 EXISTS 表示存在,后面的参数是一个任意的子查询,系统对子查询进行运算判断是否返回行,若至少返回一行
EXISTS 返回的结果为 true ,外层语句将进行查询
</code></pre>
</li>
<li>
<p>带关键字 ANY 的子查询</p>
<pre><code class="language-mysql">关键字 ANY 表示满足其中任一条件, 只要满足内层查询语句返回的结果中的任何一个,就可以通过该条件来执行外层查询语句
</code></pre>
</li>
</ul>
</li>
<li>
<p>索引</p>
<p>mysql的存储引擎对每个表至少支持16个索引，总索引长度至少为256字节</p>
<ul>
<li>
<p>普通索引</p>
<pre><code class="language-mysql">create table tablename (
	propname type,
	...
    [UNIQUE|FULLTEXT|SPATIAL] INDEX|KEY [indexname] (propname [(length)] [ASC|DESC])
);

create index indexname on tablename (propname [(length)] [ASC | DESC]);
propname指定索引对应字段的名称, length是可选参数,表示索引长度,必须是字符串类型才可以使用, ASC表示升序排列

ALTER TABLE tablename ADD INDEX|KEY indexname (propname [(length) [ASC|DESC]]);
</code></pre>
</li>
<li>
<p>唯一索引</p>
<pre><code class="language-mysql">create table tablename (
	propname type,
	...
    UNIQUE INDEX|KEY [indexname] (propname [(length)] [ASC|DESC])
);

create UNIQUE index indexname on tablename (propname [(length)] [ASC | DESC]);

ALTER TABLE tablename ADD UNIQUE INDEX|KEY indexname (propname [(length) [ASC|DESC]]);
</code></pre>
</li>
<li>
<p>删除索引</p>
<pre><code class="language-mysql">drop index indexname on tablename;
</code></pre>
</li>
</ul>
</li>
<li>
<p>事务和锁</p>
<p><a href="https://www.yuque.com/yinjianwei/vyrvkf/cl4weh">事务参考</a></p>
<p><a href="https://www.yuque.com/yinjianwei/vyrvkf/ei0mep">锁参考</a></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[垃圾收集器与内存分配策略]]></title>
        <id>https://lllhh685.github.io/post/lajishouji/</id>
        <link href="https://lllhh685.github.io/post/lajishouji/">
        </link>
        <updated>2020-10-03T11:57:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>Java内存运行区域的什么需要垃圾回收</p>
<p>Java堆和方法区</p>
</li>
<li>
<p>判断对象是否存在</p>
<p>采用的可达性分析算法，如果对象到GC Roots间没有引用链相连，或用图论从GC Roots到这个对象不可达，证明对象不可能再被使用</p>
<p>即使可达性判定为不可达，仍需要两次标记，第一次标记就是判断是否有与GC Roots相连接的引用链</p>
</li>
<li>
<p>引用</p>
<p>JDK1.2之后，将引用分为强引用、软引用、弱引用、虚引用，强度依次减弱</p>
</li>
<li>
<p>方法区回收的对象</p>
<p>废弃的常量和不再使用的类型</p>
<p>常量：如果字符串&quot;Java&quot;已进入常量池，但是系统没有字符串对象的值是&quot;Java&quot;（没有字符串对象引用常量池中的&quot;Java&quot;常量，虚拟机没有其他地方引用这个字面量），如果发生内存回收，垃圾收集器判断有必要的话，&quot;Java&quot;常量会被清理出常量池</p>
</li>
<li>
<p>垃圾收集算法</p>
<p>分<s>引用计数式垃圾收集</s>(主流不采用)和追踪式垃圾收集</p>
</li>
<li>
<p>分代收集理论：</p>
<p>假说：</p>
<ol>
<li>弱分代假说 绝大数对象式朝生熄灭的</li>
<li>强分代假说 熬过越多次垃圾收集过程的对象越难以消亡</li>
<li>跨代引用假说 跨代引用相对于同代引用来说占极少数</li>
</ol>
<p>Java堆划分为新生代和老年代两个区域，在新生代中，每次垃圾收集发现大批对象死去，每次回收后存活的少量对象逐步晋升到老年代中存放</p>
</li>
<li>
<p>垃圾收集算法思想</p>
<ol>
<li>
<p>标记清除算法</p>
<p>分为标记和清楚两个阶段，首先标记所有需要回收的对象，标记完成后，统一回收所有被标记的对象，也可以标记存活的对象，统一回收未被标记的对象。标记过程就是对象是否属于垃圾的判定过程</p>
<p>缺点 执行效率不稳定（进行大量回收时，需要进行大量标记和清除的动作，效率会降低），内存空间碎片化</p>
</li>
<li>
<p>标记复制算法</p>
<p>把新生代分为较大的Eden空间和两块较小Survivor空间，每次分配内存只使用Eden和其中一块Survivor，发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间，然后直接清理掉Eden和已使用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor大小比例时8:1，存在逃生门的安全设计。</p>
</li>
<li>
<p>标记整理算法</p>
<p>标记后将所有存活对象移向内存空间的一端，直接清理掉边界以外的内存，是移动式的算法</p>
</li>
<li>
<p>分代收集算法</p>
<p>根据对象存活周期的不同将内存划分为几块。一般是把java堆分为新生代和老年代，新生代中，每次垃圾收集有大量对象死去，使用复制算法，老年代对象存活率高使用标记清理或标记整理算法进行回收</p>
</li>
</ol>
</li>
<li>
<p>垃圾收集器</p>
<figure data-type="image" tabindex="1"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="" loading="lazy"></figure>
<ol>
<li>
<p>Serial收集器，单线程工作收集器。简单高效</p>
<figure data-type="image" tabindex="2"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="" loading="lazy"></figure>
</li>
<li>
<p>ParNew收集器，同时使用多条线程进行垃圾收集，其余行为与Serial收集器完全一致</p>
<figure data-type="image" tabindex="3"><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="" loading="lazy"></figure>
<p>除Serial收集器外，只有它能与CMS收集器配合工作</p>
</li>
<li>
<p>Parallel Scavenge收集器</p>
<p>吞吐量计算：运行代码时间   /（运行代码时间和运行垃圾收集时间）</p>
<p>目标是达到可控制的吞吐量，控制最大垃圾收集停顿时间 -XX：MaxGCPauseMillis，直接设置吞吐量大小的-XX：GCTimeRatio。</p>
<p>-XX：MaxGCPauseMillis 允许值是一个大于0的毫秒数，</p>
</li>
<li>
<p>Serial Old收集器</p>
<p>Serial收集器的老年代版本，使用标记整理算法，供客户端模式下的HotSpot虚拟机使用，服务端：JDK5以及以前与Parallel Scavenge收集器搭配使用</p>
</li>
<li>
<p>Parallel Old收集器</p>
</li>
<li>
<p>CMS收集器</p>
<p>以获取最短回收停顿时间为目标的收集器，整个过程分四个步骤</p>
<ol>
<li>初始标记：标记GC Roots能直接关联到的对象</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长无需停顿用户线程</li>
<li>重新标记：修正并发标记期间变动对象的标记记录</li>
<li>并发清除：清理删除标记阶段的判断已死亡的对象</li>
</ol>
<p>优点：并发收集、低停顿</p>
<p>缺点：吞吐量低、产生浮动垃圾（产生的垃圾对象待下一次垃圾收集时清理）、产生空间碎片，不得不提前触发一次Full GC</p>
</li>
<li>
<p>Garbage First收集器</p>
<p><img src="https://miro.medium.com/max/875/0*NzhXk29lJrjsTJ5p" alt="分代垃圾收集堆内存分布" loading="lazy">分代垃圾收集堆内存分布</p>
<p><img src="https://miro.medium.com/max/875/0*TdP79cqPt_HOXPJn" alt="" loading="lazy">G1垃圾收集堆内存分布</p>
<p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">官方指导</a></p>
</li>
</ol>
</li>
<li>
<p>内存分配策略</p>
<ol>
<li>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，发起一次Minor GC</li>
</ol>
</li>
</ul>
<ol start="2">
<li>需要大量连续内存空间的Java对象(如很长的字符串，元素数量庞大的数组)，大对象直接进入老年代</li>
<li>长期存活的对象进入老年代</li>
<li>动态对象年龄判断，为了适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄对象就可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄</li>
<li>空间分配担保，在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，虚拟机则会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，则会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试着进行一次 Minor GC，尽管这次 GC 是有风险的。如果小于，或者 HandlePromotionFailure 设置不允许冒险，则会进行 Full GC。</li>
</ol>
<ul>
<li>
<p>Minor GC 与 Full GC</p>
<p><a href="https://juejin.im/post/6844903669251440653">参考连接</a></p>
</li>
</ul>
]]></content>
    </entry>
</feed>