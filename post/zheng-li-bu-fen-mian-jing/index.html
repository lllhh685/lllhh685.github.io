<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>整理部分面经 | lnuBlog</title>

<link rel="shortcut icon" href="https://lllhh685.github.io/favicon.ico?v=1605195064585">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://lllhh685.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            lnuBlog
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1605195064585" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    整理部分面经
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-11-12 ·
                    </time>
                    
                </div>
                <div class="post-content">
                    <p>阿里</p>
<hr>
<ol>
<li>
<p>Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？</p>
<p>引用计数法：在对象中添加一个引用计数器，有一个地方引用它，计数值加一；引用失效时，计数器值减一；计数器为零的对象不再被使用</p>
<p>可达性分析算法：</p>
<p>通过称为 &quot;GC Roots&quot; 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径成为 &quot;引用链&quot;，如果某个对象到 GC Roots 间没有任何引用链相连，此对象不可能再被使用</p>
<p>GC Roots对象</p>
<ul>
<li>在虚拟机栈 (栈帧中的本地变量表) 中引用的对象，譬如各个线程被调用的方法栈中使用到的参数、局部变量、临时变量</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li>
<li>在本地方法栈中JNI (通常所说的Native方法) 引用的对象</li>
<li>Java虚拟机内部的引用</li>
<li>所有被同步锁持有的对象</li>
<li>...</li>
</ul>
<img src="https://i.imgur.com/xeKfNyU.png =" style="zoom:40%;" />
<p><a href="https://xiaogenban1993.github.io/19.09/java_jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html">G1收集</a></p>
</li>
<li>
<p>简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点</p>
</li>
<li>
<p>synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？</p>
<p>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">参考</a>，lock接口是可以显示释放锁，但是synchronized是隐式释放锁</p>
</li>
<li>
<p>JVM 中内存模型是怎样的，简述新生代与年老代的区别？</p>
</li>
<li>
<p>简述 Spring AOP 的原理</p>
</li>
<li>
<p>实现单例设计模式（懒汉，饿汉）</p>
<pre><code class="language-java">饿汉式
public class Hungry {
    private static Hungry instance = new Hungry();
    private Hungry() {

    }
    public static Hungry newInstance() {
        return instance;
    }
}
懒汉式
public class Slug {
    private static Slug instance = null;
    private Slug() {

    }
    public static Slug newInstance() {
        if(instance == null) {
            instance = new Slug();
        }
        return instance;
    }
}
</code></pre>
</li>
<li>
<p>简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度</p>
<pre><code class="language-java">ArrayList
private static final Object[] EMPTY_ELEMENTDATA = {};
private static final int DEFAULT_CAPACITY = 10;
int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
查找O(n)
LinkedList
Node节点，链表 查找O(1)
</code></pre>
</li>
<li>
<p>Java 类的加载流程是怎样的？什么是双亲委派机制？</p>
<p>类加载生命周期：</p>
<img src="http://fatfei.oss-cn-beijing.aliyuncs.com/1560087007.jpg" style="zoom:45%;" />
<p>初始化阶段时机</p>
<ol>
<li>遇到new、getstatic、putstatic 或 invokestatic这四条字节码指令，如果类型没有初始化，需先触发初始化阶段
<ul>
<li>使用new实例化对象</li>
<li>读取或设置一个类型的静态字段 (被final 修饰、已在编译期把结果放入常量池的静态字段除外) 的时候</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行初始化需先触发初始化</li>
<li>当初始化类的时候，父类没有初始化，先触发父类的初始化</li>
<li>虚拟机启动时，用户需指定一个要执行的主类 (包含main()方法的那个类) 虚拟机先初始化这个主类</li>
<li>还有两点见第三版p264</li>
</ol>
<p>类加载过程，完整第三版p267</p>
<ul>
<li>
<p>加载</p>
<p>通过类全限定名获取类的二进制字节流</p>
<p>将字节流代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>在内存中生产代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
</li>
<li>
<p>验证</p>
<p>文件格式验证：验证字节流是否符合class文件格式规范并且能被当前版本的虚拟机处理，基于二进制字节流，通过验证后字节流允许进入java虚拟机的方法区进行存储</p>
<p>元数据验证：对字节码描述的信息进行语义分析</p>
<p>字节码验证：通过数据流分析和控制流分析确定程序语义是合法的、符合逻辑的</p>
<p>符号引用验证：发生在符号引用转化为直接引用时，转化动作发生在连接的第三阶段--解析阶段</p>
</li>
<li>
<p>准备</p>
<p>正式为类中定义的变量 (静态变量) 分配内存并设置类变量初始值的阶段</p>
</li>
<li>
<p>解析</p>
<p>java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
</li>
<li>
<p>初始化</p>
<p>执行类构造器<clinit>()方法的过程</p>
</li>
</ul>
<p>双亲委派模型</p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应有自己的父类加载器，类加载器之间的父子关系通常使用组合关系复用父类加载器的代码</p>
<p>工作过程：如果一个类加载器收到了类加载的请求，把请求委派给父类加载器去完成，每层类加载器都是如此，所有的加载请求最终都应传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成加载请求时，子加载器才会尝试自己去完成加载<br>
<a href="https://img-blog.csdn.net/20160506184936657">图片</a><br>
破坏双亲委派模型</p>
<p>第一次破坏：jdk1.2前 (双亲委派模型出现在jdk1.2之后)</p>
<p>第二次破坏：模型自身缺陷</p>
<p>第三次破环：用户对程序动态性的追求导致</p>
</li>
<li>
<p>简述 Java 的反射机制</p>
<p>可以动态操控java代码的程序，有分析类的能力</p>
</li>
<li>
<p>Java 中 sleep() 与 wait() 的区别</p>
<p>调用wait()方法，调用线程会被阻塞并释放锁，应在同步代码块中调用，能够被notify和notifyAll线程唤醒</p>
<p>Thread.sleep()方法是一个静态方法，针对线程，不能被notify方法唤醒</p>
</li>
<li>
<p>String 类能不能被继承？为什么？</p>
<p>final修饰，不能继承；不存在线程安全问题，语义合理</p>
<p><a href="http://dengchengchao.com/?p=1096">参考</a></p>
</li>
<li>
<p>hashcode 和 equals 方法的联系</p>
<p>调用equals返回true的两个对象具有相等的哈希码</p>
<p>如果两个对象的hashcode返回值相同，调用equals方法不一定返回true</p>
</li>
<li>
<p>Spring MVC 的原理和流程</p>
<ol>
<li>DispatcherServlet拦截请求</li>
<li>调用处理器映射器HandlerMapping</li>
<li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain</li>
<li>执行处理器Controller</li>
<li>完成返回ModelAndView</li>
<li>传给ViewReslover视图解析器</li>
<li>返回视图</li>
</ol>
<p><a href="https://www.javazhiyin.com/33187.html">参考</a></p>
</li>
<li>
<p>Java 缓冲流 buffer 的用途和原理是什么</p>
<p>利用数组进行数据缓冲，进行IO操作时使用可提高效率</p>
<p><a href="https://developer.ibm.com/zh/articles/j-lo-javaio/">参考</a></p>
</li>
<li>
<p>生产者消费者模型</p>
</li>
<li>
<p>Linux 下如何排查 CPU 以及 内存占用过多</p>
<p>top命令</p>
</li>
<li>
<p>正在运行的进程，某个端口对应的进程</p>
<p>netstat | grep端口号</p>
</li>
<li>
<p>MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？</p>
<p>主键索引&lt;id, row&gt;，辅助索引&lt;index, id&gt;</p>
<p>主键索引中，<code>id</code> 是主键，我们能够通过 <code>id</code> 找到该行的全部列</p>
<p>辅助索引中，索引中的几个列构成了键，我们能够通过索引中的列找到 <code>id</code>，如果有需要的话，可以再通过 <code>id</code> 找到当前数据行的全部内容；</p>
<p>B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</p>
</li>
<li>
<p>数据库的事务隔离级别有哪些？各有哪些优缺点？</p>
<p>未提交读--脏读，已提交读--不可重复读，可重复读--幻读，可串行化</p>
</li>
<li>
<p>简述乐观锁以及悲观锁的区别以及使用场景</p>
<p>悲观锁：每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁，适合写入操作比较频繁的场景</p>
<p>乐观锁：每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。适合读取操作比较频繁的场景</p>
</li>
<li>
<p>简述脏读和幻读的发生场景，InnoDB 是如何解决幻读的</p>
<p>脏读：事务读取未提交的数据</p>
<p>不可重复读：前后多次读取，数据内容不一致</p>
<p>幻读：前后多次读取，数据总量不一致</p>
<p>间隙锁解决幻读，间隙锁锁定查询的涉及的行，还会对索引中间的间隙进行锁定，防止幻影行的插入</p>
</li>
<li>
<p>简述 Redis 持久化中 rdb 以及 aof 方案的优缺点</p>
<p>rdb (redis database)：在指定的时间间隔内将内存中的数据集快照写入磁盘，RDB的缺点是最后一次持久化后的数据可能丢失</p>
<p>aof (append only file)：日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件</p>
<p>但不可以改写文件，缺点：aof 默认就是文件的无限追加，文件会越来越大</p>
</li>
<li>
<p>数据库查询中左外连接和内连接的区别是什么</p>
<p>内连接结果取交集，外连接结果取并集</p>
</li>
<li>
<p>数据库的读写分离的作用是什么？如何实现？</p>
<p>让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。减少数据库压力，提高性能</p>
</li>
<li>
<p>简述 Redis 中跳表的应用以及优缺点</p>
</li>
<li>
<p>Redis的缓存淘汰策略有哪些？</p>
<p>volatile-lru：从设置过期的数据集中淘汰最少使用的 key</p>
<p>volatile-ttl：从设置过期的数据集中淘汰即将过期的 key</p>
<p>volatile-random：从设置过期的数据集中随机选取 key 淘汰</p>
<p>allkeys-lru：从所有的数据集中选取最少使用的数据</p>
<p>allkyes-random：从所有的数据集中任意选取数据淘汰</p>
<p>no-envicition：不进行淘汰</p>
</li>
<li>
<p>Redis 如何实现分布式锁？</p>
<p><a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">参考</a></p>
</li>
<li>
<p><s>Redis 序列化有哪些方式？</s></p>
</li>
<li>
<p>简述 MySQL 三种日志的使用场景</p>
<p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎</p>
<p>都可以使用。</p>
<p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日</p>
<p>志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p>
<p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指</p>
<p>binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</p>
</li>
<li>
<p>模糊查询是如何实现的？</p>
</li>
<li>
<p>sentine l和 cluster 的区别和适用场景是什么？</p>
</li>
<li>
<p>为什么 Redis 在单线程下能如此快？</p>
<p>严格来说，Redis Server是多线程的，只是它的请求处理整个流程是单线程处理的。</p>
<p>Redis是一个KV内存数据库，操作都在内存中进行，并不会大量消耗CPU资源，所以速度极快</p>
<p>单线程模型没有了多线程上下文切换的性能损耗</p>
<p>Redis 6.0，Redis又引入了多线程来完成请求数据的协议解析，进一步提升性能。它主要是解决高并发场景下，单线程解析请求数据协议带来的压力。请求数据的协议解析由多线程完成之后，后面的请求处理阶段依旧还是单线程排队处理。https://img-blog.csdn.net/20160506184936657</p>
</li>
</ol>
<p><a href="https://www.shanruifeng.win/">GC Roots photo参考链接</a></p>
<p><a href="https://huija.github.io/2018/12/06/Interview-problems/">面试题连接</a></p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://lllhh685.github.io/post/mysql/" class="post-title gt-a-link">
                    MySQL
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">keep trying</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://lllhh685.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
